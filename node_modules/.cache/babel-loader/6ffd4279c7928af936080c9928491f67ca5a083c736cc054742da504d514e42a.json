{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useEffect, useCallback } from 'react';\nimport { scrollConfig } from '../config/scrollConfig';\nexport const useAutoScroll = (elementRef, isHovered) => {\n  _s();\n  const smoothScrollTo = useCallback((element, targetLeft) => {\n    const startLeft = element.scrollLeft;\n    const distance = targetLeft - startLeft;\n    const duration = scrollConfig.transitionDuration;\n    let startTime = null;\n    const animateScroll = currentTime => {\n      if (startTime === null) startTime = currentTime;\n      const timeElapsed = currentTime - startTime;\n      const progress = Math.min(timeElapsed / duration, 1);\n\n      // Easing function for smoother animation\n      const easeInOutQuad = t => {\n        return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;\n      };\n      const newPosition = startLeft + distance * easeInOutQuad(progress);\n      element.scrollLeft = newPosition;\n      if (progress < 1) {\n        requestAnimationFrame(animateScroll);\n      }\n    };\n    requestAnimationFrame(animateScroll);\n  }, []);\n  const autoScroll = useCallback(element => {\n    if (element) {\n      const tileWidth = element.clientWidth / scrollConfig.tilesPerView;\n      const isAtEnd = element.scrollLeft + element.clientWidth >= element.scrollWidth;\n      const scrollStep = tileWidth / scrollConfig.stepsPerTile;\n      if (isAtEnd) {\n        // Smooth transition to the start\n        smoothScrollTo(element, 0);\n\n        // After reset delay, continue scrolling\n        setTimeout(() => {\n          smoothScrollTo(element, scrollStep);\n        }, scrollConfig.resetDelay);\n      } else {\n        // Calculate next position\n        const nextPosition = element.scrollLeft + scrollStep;\n        smoothScrollTo(element, nextPosition);\n      }\n    }\n  }, [smoothScrollTo]);\n  useEffect(() => {\n    let scrollInterval;\n    if (!isHovered && elementRef.current) {\n      scrollInterval = setInterval(() => {\n        autoScroll(elementRef.current);\n      }, scrollConfig.frameRate);\n    }\n    return () => {\n      clearInterval(scrollInterval);\n    };\n  }, [isHovered, elementRef, autoScroll]);\n};\n_s(useAutoScroll, \"L9AwTKzPb8Ih/dm8B0aJKHCHwsg=\");","map":{"version":3,"names":["useEffect","useCallback","scrollConfig","useAutoScroll","elementRef","isHovered","_s","smoothScrollTo","element","targetLeft","startLeft","scrollLeft","distance","duration","transitionDuration","startTime","animateScroll","currentTime","timeElapsed","progress","Math","min","easeInOutQuad","t","newPosition","requestAnimationFrame","autoScroll","tileWidth","clientWidth","tilesPerView","isAtEnd","scrollWidth","scrollStep","stepsPerTile","setTimeout","resetDelay","nextPosition","scrollInterval","current","setInterval","frameRate","clearInterval"],"sources":["/Users/sandipkumar.yadav/Desktop/image-gallery/src/hooks/useAutoScroll.ts"],"sourcesContent":["import { useEffect, RefObject, useCallback } from 'react';\nimport { scrollConfig } from '../config/scrollConfig';\n\nexport const useAutoScroll = (\n  elementRef: RefObject<HTMLDivElement | null>,\n  isHovered: boolean\n) => {\n  const smoothScrollTo = useCallback((element: HTMLDivElement, targetLeft: number) => {\n    const startLeft = element.scrollLeft;\n    const distance = targetLeft - startLeft;\n    const duration = scrollConfig.transitionDuration;\n    let startTime: number | null = null;\n\n    const animateScroll = (currentTime: number) => {\n      if (startTime === null) startTime = currentTime;\n      const timeElapsed = currentTime - startTime;\n      const progress = Math.min(timeElapsed / duration, 1);\n\n      // Easing function for smoother animation\n      const easeInOutQuad = (t: number) => {\n        return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;\n      };\n\n      const newPosition = startLeft + distance * easeInOutQuad(progress);\n      element.scrollLeft = newPosition;\n\n      if (progress < 1) {\n        requestAnimationFrame(animateScroll);\n      }\n    };\n\n    requestAnimationFrame(animateScroll);\n  }, []);\n\n  const autoScroll = useCallback((element: HTMLDivElement | null) => {\n    if (element) {\n      const tileWidth = element.clientWidth / scrollConfig.tilesPerView;\n      const isAtEnd = element.scrollLeft + element.clientWidth >= element.scrollWidth;\n      const scrollStep = tileWidth / scrollConfig.stepsPerTile;\n\n      if (isAtEnd) {\n        // Smooth transition to the start\n        smoothScrollTo(element, 0);\n        \n        // After reset delay, continue scrolling\n        setTimeout(() => {\n          smoothScrollTo(element, scrollStep);\n        }, scrollConfig.resetDelay);\n      } else {\n        // Calculate next position\n        const nextPosition = element.scrollLeft + scrollStep;\n        smoothScrollTo(element, nextPosition);\n      }\n    }\n  }, [smoothScrollTo]);\n\n  useEffect(() => {\n    let scrollInterval: NodeJS.Timeout;\n\n    if (!isHovered && elementRef.current) {\n      scrollInterval = setInterval(() => {\n        autoScroll(elementRef.current);\n      }, scrollConfig.frameRate);\n    }\n\n    return () => {\n      clearInterval(scrollInterval);\n    };\n  }, [isHovered, elementRef, autoScroll]);\n}; "],"mappings":";AAAA,SAASA,SAAS,EAAaC,WAAW,QAAQ,OAAO;AACzD,SAASC,YAAY,QAAQ,wBAAwB;AAErD,OAAO,MAAMC,aAAa,GAAGA,CAC3BC,UAA4C,EAC5CC,SAAkB,KACf;EAAAC,EAAA;EACH,MAAMC,cAAc,GAAGN,WAAW,CAAC,CAACO,OAAuB,EAAEC,UAAkB,KAAK;IAClF,MAAMC,SAAS,GAAGF,OAAO,CAACG,UAAU;IACpC,MAAMC,QAAQ,GAAGH,UAAU,GAAGC,SAAS;IACvC,MAAMG,QAAQ,GAAGX,YAAY,CAACY,kBAAkB;IAChD,IAAIC,SAAwB,GAAG,IAAI;IAEnC,MAAMC,aAAa,GAAIC,WAAmB,IAAK;MAC7C,IAAIF,SAAS,KAAK,IAAI,EAAEA,SAAS,GAAGE,WAAW;MAC/C,MAAMC,WAAW,GAAGD,WAAW,GAAGF,SAAS;MAC3C,MAAMI,QAAQ,GAAGC,IAAI,CAACC,GAAG,CAACH,WAAW,GAAGL,QAAQ,EAAE,CAAC,CAAC;;MAEpD;MACA,MAAMS,aAAa,GAAIC,CAAS,IAAK;QACnC,OAAOA,CAAC,GAAG,GAAG,GAAG,CAAC,GAAGA,CAAC,GAAGA,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,GAAGA,CAAC,IAAIA,CAAC;MACnD,CAAC;MAED,MAAMC,WAAW,GAAGd,SAAS,GAAGE,QAAQ,GAAGU,aAAa,CAACH,QAAQ,CAAC;MAClEX,OAAO,CAACG,UAAU,GAAGa,WAAW;MAEhC,IAAIL,QAAQ,GAAG,CAAC,EAAE;QAChBM,qBAAqB,CAACT,aAAa,CAAC;MACtC;IACF,CAAC;IAEDS,qBAAqB,CAACT,aAAa,CAAC;EACtC,CAAC,EAAE,EAAE,CAAC;EAEN,MAAMU,UAAU,GAAGzB,WAAW,CAAEO,OAA8B,IAAK;IACjE,IAAIA,OAAO,EAAE;MACX,MAAMmB,SAAS,GAAGnB,OAAO,CAACoB,WAAW,GAAG1B,YAAY,CAAC2B,YAAY;MACjE,MAAMC,OAAO,GAAGtB,OAAO,CAACG,UAAU,GAAGH,OAAO,CAACoB,WAAW,IAAIpB,OAAO,CAACuB,WAAW;MAC/E,MAAMC,UAAU,GAAGL,SAAS,GAAGzB,YAAY,CAAC+B,YAAY;MAExD,IAAIH,OAAO,EAAE;QACX;QACAvB,cAAc,CAACC,OAAO,EAAE,CAAC,CAAC;;QAE1B;QACA0B,UAAU,CAAC,MAAM;UACf3B,cAAc,CAACC,OAAO,EAAEwB,UAAU,CAAC;QACrC,CAAC,EAAE9B,YAAY,CAACiC,UAAU,CAAC;MAC7B,CAAC,MAAM;QACL;QACA,MAAMC,YAAY,GAAG5B,OAAO,CAACG,UAAU,GAAGqB,UAAU;QACpDzB,cAAc,CAACC,OAAO,EAAE4B,YAAY,CAAC;MACvC;IACF;EACF,CAAC,EAAE,CAAC7B,cAAc,CAAC,CAAC;EAEpBP,SAAS,CAAC,MAAM;IACd,IAAIqC,cAA8B;IAElC,IAAI,CAAChC,SAAS,IAAID,UAAU,CAACkC,OAAO,EAAE;MACpCD,cAAc,GAAGE,WAAW,CAAC,MAAM;QACjCb,UAAU,CAACtB,UAAU,CAACkC,OAAO,CAAC;MAChC,CAAC,EAAEpC,YAAY,CAACsC,SAAS,CAAC;IAC5B;IAEA,OAAO,MAAM;MACXC,aAAa,CAACJ,cAAc,CAAC;IAC/B,CAAC;EACH,CAAC,EAAE,CAAChC,SAAS,EAAED,UAAU,EAAEsB,UAAU,CAAC,CAAC;AACzC,CAAC;AAACpB,EAAA,CAlEWH,aAAa","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}