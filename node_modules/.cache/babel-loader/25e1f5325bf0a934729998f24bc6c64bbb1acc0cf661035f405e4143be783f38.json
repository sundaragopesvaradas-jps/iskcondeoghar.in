{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useEffect } from 'react';\nimport { scrollConfig } from '../config/scrollConfig';\nexport const useAutoScroll = (elementRef, isHovered) => {\n  _s();\n  useEffect(() => {\n    let scrollInterval;\n    if (elementRef.current) {\n      const scroll = () => {\n        const element = elementRef.current;\n        if (!element) return;\n        const tileWidth = element.clientWidth / scrollConfig.tilesPerView;\n        const isAtEnd = element.scrollLeft + element.clientWidth >= element.scrollWidth;\n        if (isAtEnd) {\n          // Reset to start\n          element.scrollLeft = 0;\n        } else {\n          // Scroll one tile\n          element.scrollBy({\n            left: tileWidth,\n            behavior: scrollConfig.scrollBehavior\n          });\n        }\n      };\n\n      // Set interval based on scrollTimePerTile\n      scrollInterval = setInterval(scroll, scrollConfig.scrollTimePerTile);\n    }\n    return () => {\n      if (scrollInterval) {\n        clearInterval(scrollInterval);\n      }\n      // Reset position when unmounting\n      if (elementRef.current) {\n        elementRef.current.scrollLeft = 0;\n      }\n    };\n  }, [elementRef]);\n};\n_s(useAutoScroll, \"OD7bBpZva5O2jO+Puf00hKivP7c=\");","map":{"version":3,"names":["useEffect","scrollConfig","useAutoScroll","elementRef","isHovered","_s","scrollInterval","current","scroll","element","tileWidth","clientWidth","tilesPerView","isAtEnd","scrollLeft","scrollWidth","scrollBy","left","behavior","scrollBehavior","setInterval","scrollTimePerTile","clearInterval"],"sources":["/Users/sandipkumar.yadav/Desktop/image-gallery/src/hooks/useAutoScroll.ts"],"sourcesContent":["import { useEffect, RefObject } from 'react';\nimport { scrollConfig } from '../config/scrollConfig';\n\nexport const useAutoScroll = (\n  elementRef: RefObject<HTMLDivElement | null>,\n  isHovered: boolean\n) => {\n  useEffect(() => {\n    let scrollInterval: NodeJS.Timeout;\n\n    if (elementRef.current) {\n      const scroll = () => {\n        const element = elementRef.current;\n        if (!element) return;\n\n        const tileWidth = element.clientWidth / scrollConfig.tilesPerView;\n        const isAtEnd = element.scrollLeft + element.clientWidth >= element.scrollWidth;\n\n        if (isAtEnd) {\n          // Reset to start\n          element.scrollLeft = 0;\n        } else {\n          // Scroll one tile\n          element.scrollBy({\n            left: tileWidth,\n            behavior: scrollConfig.scrollBehavior\n          });\n        }\n      };\n\n      // Set interval based on scrollTimePerTile\n      scrollInterval = setInterval(scroll, scrollConfig.scrollTimePerTile);\n    }\n\n    return () => {\n      if (scrollInterval) {\n        clearInterval(scrollInterval);\n      }\n      // Reset position when unmounting\n      if (elementRef.current) {\n        elementRef.current.scrollLeft = 0;\n      }\n    };\n  }, [elementRef]);\n}; "],"mappings":";AAAA,SAASA,SAAS,QAAmB,OAAO;AAC5C,SAASC,YAAY,QAAQ,wBAAwB;AAErD,OAAO,MAAMC,aAAa,GAAGA,CAC3BC,UAA4C,EAC5CC,SAAkB,KACf;EAAAC,EAAA;EACHL,SAAS,CAAC,MAAM;IACd,IAAIM,cAA8B;IAElC,IAAIH,UAAU,CAACI,OAAO,EAAE;MACtB,MAAMC,MAAM,GAAGA,CAAA,KAAM;QACnB,MAAMC,OAAO,GAAGN,UAAU,CAACI,OAAO;QAClC,IAAI,CAACE,OAAO,EAAE;QAEd,MAAMC,SAAS,GAAGD,OAAO,CAACE,WAAW,GAAGV,YAAY,CAACW,YAAY;QACjE,MAAMC,OAAO,GAAGJ,OAAO,CAACK,UAAU,GAAGL,OAAO,CAACE,WAAW,IAAIF,OAAO,CAACM,WAAW;QAE/E,IAAIF,OAAO,EAAE;UACX;UACAJ,OAAO,CAACK,UAAU,GAAG,CAAC;QACxB,CAAC,MAAM;UACL;UACAL,OAAO,CAACO,QAAQ,CAAC;YACfC,IAAI,EAAEP,SAAS;YACfQ,QAAQ,EAAEjB,YAAY,CAACkB;UACzB,CAAC,CAAC;QACJ;MACF,CAAC;;MAED;MACAb,cAAc,GAAGc,WAAW,CAACZ,MAAM,EAAEP,YAAY,CAACoB,iBAAiB,CAAC;IACtE;IAEA,OAAO,MAAM;MACX,IAAIf,cAAc,EAAE;QAClBgB,aAAa,CAAChB,cAAc,CAAC;MAC/B;MACA;MACA,IAAIH,UAAU,CAACI,OAAO,EAAE;QACtBJ,UAAU,CAACI,OAAO,CAACO,UAAU,GAAG,CAAC;MACnC;IACF,CAAC;EACH,CAAC,EAAE,CAACX,UAAU,CAAC,CAAC;AAClB,CAAC;AAACE,EAAA,CAzCWH,aAAa","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}