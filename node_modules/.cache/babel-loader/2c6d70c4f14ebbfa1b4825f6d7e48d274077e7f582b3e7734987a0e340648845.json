{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useEffect, useCallback } from 'react';\nimport { scrollConfig } from '../config/scrollConfig';\nexport const useAutoScroll = (elementRef, isHovered) => {\n  _s();\n  const smoothScrollTo = useCallback((element, targetLeft) => {\n    const startLeft = element.scrollLeft;\n    const distance = targetLeft - startLeft;\n    const duration = scrollConfig.transitionDuration;\n    let startTime = null;\n    const animateScroll = currentTime => {\n      if (startTime === null) startTime = currentTime;\n      const timeElapsed = currentTime - startTime;\n      const progress = Math.min(timeElapsed / duration, 1);\n\n      // Easing function for smoother animation\n      const easeInOutQuad = t => {\n        return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;\n      };\n      const newPosition = startLeft + distance * easeInOutQuad(progress);\n      element.scrollLeft = newPosition;\n      if (progress < 1) {\n        requestAnimationFrame(animateScroll);\n      }\n    };\n    requestAnimationFrame(animateScroll);\n  }, []);\n  const autoScroll = useCallback(element => {\n    if (element) {\n      const tileWidth = element.clientWidth / scrollConfig.tilesPerView;\n      const isAtEnd = element.scrollLeft + element.clientWidth >= element.scrollWidth;\n      const scrollStep = tileWidth / scrollConfig.stepsPerTile;\n      if (isAtEnd) {\n        // Instead of smooth scrolling to 0, instantly reset to start\n        element.style.scrollBehavior = 'auto';\n        element.scrollLeft = 0;\n        element.style.scrollBehavior = 'smooth';\n\n        // After reset delay, continue scrolling\n        setTimeout(() => {\n          smoothScrollTo(element, scrollStep);\n        }, scrollConfig.resetDelay);\n      } else {\n        // Calculate next position\n        const nextPosition = element.scrollLeft + scrollStep;\n        smoothScrollTo(element, nextPosition);\n      }\n    }\n  }, [smoothScrollTo]);\n  useEffect(() => {\n    let scrollInterval;\n    if (elementRef.current) {\n      scrollInterval = setInterval(() => {\n        autoScroll(elementRef.current);\n      }, scrollConfig.frameRate);\n    }\n    return () => {\n      if (scrollInterval) {\n        clearInterval(scrollInterval);\n      }\n      // Reset scroll position when unmounting\n      if (elementRef.current) {\n        elementRef.current.scrollLeft = 0;\n      }\n    };\n  }, [elementRef, autoScroll]); // Removed isHovered from dependencies\n};\n_s(useAutoScroll, \"L9AwTKzPb8Ih/dm8B0aJKHCHwsg=\");","map":{"version":3,"names":["useEffect","useCallback","scrollConfig","useAutoScroll","elementRef","isHovered","_s","smoothScrollTo","element","targetLeft","startLeft","scrollLeft","distance","duration","transitionDuration","startTime","animateScroll","currentTime","timeElapsed","progress","Math","min","easeInOutQuad","t","newPosition","requestAnimationFrame","autoScroll","tileWidth","clientWidth","tilesPerView","isAtEnd","scrollWidth","scrollStep","stepsPerTile","style","scrollBehavior","setTimeout","resetDelay","nextPosition","scrollInterval","current","setInterval","frameRate","clearInterval"],"sources":["/Users/sandipkumar.yadav/Desktop/image-gallery/src/hooks/useAutoScroll.ts"],"sourcesContent":["import { useEffect, RefObject, useCallback } from 'react';\nimport { scrollConfig } from '../config/scrollConfig';\n\nexport const useAutoScroll = (\n  elementRef: RefObject<HTMLDivElement | null>,\n  isHovered: boolean\n) => {\n  const smoothScrollTo = useCallback((element: HTMLDivElement, targetLeft: number) => {\n    const startLeft = element.scrollLeft;\n    const distance = targetLeft - startLeft;\n    const duration = scrollConfig.transitionDuration;\n    let startTime: number | null = null;\n\n    const animateScroll = (currentTime: number) => {\n      if (startTime === null) startTime = currentTime;\n      const timeElapsed = currentTime - startTime;\n      const progress = Math.min(timeElapsed / duration, 1);\n\n      // Easing function for smoother animation\n      const easeInOutQuad = (t: number) => {\n        return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;\n      };\n\n      const newPosition = startLeft + distance * easeInOutQuad(progress);\n      element.scrollLeft = newPosition;\n\n      if (progress < 1) {\n        requestAnimationFrame(animateScroll);\n      }\n    };\n\n    requestAnimationFrame(animateScroll);\n  }, []);\n\n  const autoScroll = useCallback((element: HTMLDivElement | null) => {\n    if (element) {\n      const tileWidth = element.clientWidth / scrollConfig.tilesPerView;\n      const isAtEnd = element.scrollLeft + element.clientWidth >= element.scrollWidth;\n      const scrollStep = tileWidth / scrollConfig.stepsPerTile;\n\n      if (isAtEnd) {\n        // Instead of smooth scrolling to 0, instantly reset to start\n        element.style.scrollBehavior = 'auto';\n        element.scrollLeft = 0;\n        element.style.scrollBehavior = 'smooth';\n        \n        // After reset delay, continue scrolling\n        setTimeout(() => {\n          smoothScrollTo(element, scrollStep);\n        }, scrollConfig.resetDelay);\n      } else {\n        // Calculate next position\n        const nextPosition = element.scrollLeft + scrollStep;\n        smoothScrollTo(element, nextPosition);\n      }\n    }\n  }, [smoothScrollTo]);\n\n  useEffect(() => {\n    let scrollInterval: NodeJS.Timeout;\n\n    if (elementRef.current) {\n      scrollInterval = setInterval(() => {\n        autoScroll(elementRef.current);\n      }, scrollConfig.frameRate);\n    }\n\n    return () => {\n      if (scrollInterval) {\n        clearInterval(scrollInterval);\n      }\n      // Reset scroll position when unmounting\n      if (elementRef.current) {\n        elementRef.current.scrollLeft = 0;\n      }\n    };\n  }, [elementRef, autoScroll]); // Removed isHovered from dependencies\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}